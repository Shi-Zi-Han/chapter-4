<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pythonæ•°æ®å¯è§†åŒ– - äº¤äº’å¼å›¾è¡¨æ ·å¼è®¾ç½®ï¼ˆä¼˜åŒ–ç‰ˆï¼‰</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    
    <!-- ç°ä»£CSSæ ·å¼ -->
    <style>
        /* CSSå˜é‡å®šä¹‰ - æ”¯æŒä¸»é¢˜åˆ‡æ¢ */
        :root {
            /* é»˜è®¤ä¸»é¢˜ (æµ…è‰²) */
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --accent-color: #e74c3c;
            --success-color: #27ae60;
            --warning-color: #e67e22;
            --background-color: #ffffff;
            --surface-color: #f8f9fa;
            --text-primary: #2c3e50;
            --text-secondary: #7f8c8d;
            --border-color: #e9ecef;
            --shadow-color: rgba(0,0,0,0.1);
            --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-header: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
        }
        
        /* æ·±è‰²ä¸»é¢˜ */
        [data-theme="dark"] {
            --primary-color: #3498db;
            --secondary-color: #34495e;
            --accent-color: #e74c3c;
            --success-color: #27ae60;
            --warning-color: #e67e22;
            --background-color: #1a1a1a;
            --surface-color: #2c3e50;
            --text-primary: #ecf0f1;
            --text-secondary: #bdc3c7;
            --border-color: #34495e;
            --shadow-color: rgba(0,0,0,0.3);
            --gradient-primary: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            --gradient-header: linear-gradient(135deg, #34495e 0%, #2980b9 100%);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--gradient-primary);
            min-height: 100vh;
            padding: 20px;
            color: var(--text-primary);
            transition: all 0.3s ease;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--background-color);
            border-radius: 15px;
            box-shadow: 0 20px 40px var(--shadow-color);
            overflow: hidden;
            transition: all 0.3s ease;
        }

        /* ä¸»é¢˜åˆ‡æ¢æ§ä»¶ */
        .theme-switcher {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: var(--surface-color);
            border-radius: 25px;
            padding: 10px;
            box-shadow: 0 5px 15px var(--shadow-color);
            display: flex;
            gap: 5px;
        }
        
        .theme-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .theme-btn:hover { transform: scale(1.1); }
        .theme-btn.active { transform: scale(1.1); box-shadow: 0 3px 10px var(--shadow-color); }
        .theme-light { background: linear-gradient(135deg, #3498db, #2c3e50); color: white; }
        .theme-dark { background: linear-gradient(135deg, #34495e, #2c3e50); color: white; }


        .header {
            background: var(--gradient-header);
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .header h1 { font-size: 2.5em; margin-bottom: 10px; text-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .header p { font-size: 1.2em; opacity: 0.9; }

        .controls {
            background: var(--surface-color);
            padding: 25px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .chart-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .chart-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            background: var(--primary-color);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            position: relative;
            overflow: hidden;
        }
        
        .chart-btn:hover { background: var(--accent-color); }
        .chart-btn.active { background: var(--accent-color); box-shadow: 0 4px 8px var(--shadow-color); }

        .interactive-panel {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            padding: 25px;
            min-height: 500px;
        }
        
        .control-panel {
            background: var(--surface-color);
            border-radius: 10px;
            padding: 20px;
            border: 1px solid var(--border-color);
        }
        
        .control-section {
            margin-bottom: 25px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
        }
        
        .control-section h3 {
            color: var(--text-primary);
            margin-bottom: 15px;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .control-section h3 .collapse-arrow {
            cursor: pointer;
            transition: transform 0.3s ease;
            font-size: 14px;
        }
        
        .control-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
        }
        
        .control-content.active { 
            max-height: 2000px;
            overflow: visible;
        }
        
        .control-section.expanded .control-content {
            max-height: 2000px;
            overflow: visible;
        }
        
        .control-item {
            margin-bottom: 15px;
        }
        
        .control-item label {
            display: block;
            margin-bottom: 5px;
            color: var(--text-secondary);
            font-size: 14px;
        }
        
        .control-item input[type="text"],
        .control-item input[type="number"],
        .control-item select {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--background-color);
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .control-item input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        .data-table th,
        .data-table td {
            padding: 8px;
            border: 1px solid var(--border-color);
            text-align: center;
        }
        
        .data-table th {
            background: var(--primary-color);
            color: white;
            font-weight: 600;
        }
        
        .data-table input {
            width: 80px;
            padding: 4px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            text-align: center;
        }
        
        .visualization-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        #chart-container {
            width: 100%;
            height: 600px;
            background: var(--background-color);
            border-radius: 10px;
            border: 1px solid var(--border-color);
        }
        
        .download-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .download-btn {
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            background: var(--primary-color);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }
        
        .download-btn:hover { background: var(--accent-color); }
        
        .confirm-btn {
            background: var(--success-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            transition: all 0.3s ease;
        }
        
        .confirm-btn:hover { background: #219653; }
        
        .confirm-btn.loading { background: var(--warning-color); pointer-events: none; }
        .confirm-btn.success { background: #27ae60; }
        .confirm-btn.error { background: #e74c3c; }
        
        .validation-message {
            margin-top: 10px;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .validation-success { background: #d4edda; color: #155724; }
        .validation-error { background: #f8d7da; color: #721c24; }
        .validation-warning { background: #fff3cd; color: #856404; }

        /* å›¾è¡¨è¯´æ˜åŒºåŸŸæ ·å¼ */
        .chart-explanation-container {
            background: var(--surface-color);
            border-radius: 10px;
            padding: 20px;
            border: 1px solid var(--border-color);
            margin-top: 20px;
        }
        
        .chart-explanation-container h3 {
            color: var(--text-primary);
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
        }
        
        .chart-explanation {
            display: block;
        }
        
        .chart-explanation h4 {
            color: var(--text-primary);
            margin-bottom: 10px;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .chart-explanation p {
            color: var(--text-secondary);
            line-height: 1.6;
            font-size: 14px;
            text-align: justify;
        }
        
        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .interactive-panel {
                grid-template-columns: 1fr;
            }
            
            .control-panel {
                order: 2;
            }
            
            #chart-container {
                height: 400px;
            }
            
            .download-controls {
                justify-content: center;
            }
            
            .chart-explanation-container {
                padding: 15px;
            }
            
            .chart-explanation h4 {
                font-size: 15px;
            }
            
            .chart-explanation p {
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <div class="theme-switcher">
        <button class="theme-btn theme-light active" onclick="setTheme('light')">â˜€ï¸</button>
        <button class="theme-btn theme-dark" onclick="setTheme('dark')">ğŸŒ™</button>
    </div>

    <div class="container">
        <div class="header">
            <h1>ğŸ“Š äº¤äº’å¼æ•°æ®å¯è§†åŒ–</h1>
            <p>åŸºäºPythonæ•°æ®å¯è§†åŒ–ç¬¬4ç«  - å®Œæ•´çš„äº¤äº’å¼å›¾è¡¨æ ·å¼è®¾ç½®</p>
        </div>

        <div class="controls">
            <div class="chart-selector">
                <button class="chart-btn active" onclick="switchChart('book-purchase')">ğŸ“š å›¾ä¹¦é‡‡è´­æƒ…å†µ</button>
                <button class="chart-btn" onclick="switchChart('exchange-rate')">ğŸ’± æ±‡ç‡èµ°åŠ¿</button>
                <button class="chart-btn" onclick="switchChart('sales')">ğŸ“ˆ äº§å“é”€å”®é¢</button>
                <button class="chart-btn" onclick="switchChart('temperature')">ğŸŒ¡ï¸ æ¸©åº¦å˜åŒ–</button>
                <button class="chart-btn" onclick="switchChart('snowflake')">â„ï¸ ç§‘èµ«é›ªèŠ±</button>
            </div>
        </div>

        <div class="interactive-panel">
            <div class="control-panel">
                <!-- æ•°æ®ç¼–è¾‘é¢æ¿ -->
                <div class="control-section">
                    <h3 onclick="toggleCollapse(this)">
                        ğŸ“‹ æ•°æ®ç¼–è¾‘
                        <span class="collapse-arrow">â–¼</span>
                    </h3>
                    <div class="control-content active" id="data-editor">
                        <!-- åŠ¨æ€ç”Ÿæˆæ•°æ®è¡¨æ ¼ -->
                    </div>
                    <div class="validation-message" id="data-validation"></div>
                    <button class="confirm-btn" id="data-confirm-btn" onclick="confirmDataChanges()">âœ… ç¡®è®¤æ•°æ®ä¿®æ”¹</button>
                </div>

                <!-- é¢œè‰²é…ç½®é¢æ¿ -->
                <div class="control-section">
                    <h3 onclick="toggleCollapse(this)">
                        ğŸ¨ é¢œè‰²é…ç½®
                        <span class="collapse-arrow">â–¼</span>
                    </h3>
                    <div class="control-content active" id="color-controls">
                        <!-- åŠ¨æ€ç”Ÿæˆé¢œè‰²é€‰æ‹©å™¨ -->
                    </div>
                    <div class="validation-message" id="color-validation"></div>
                    <button class="confirm-btn" id="color-confirm-btn" onclick="confirmColorChanges()">âœ… ç¡®è®¤é¢œè‰²ä¿®æ”¹</button>
                </div>

                <!-- å›¾è¡¨è®¾ç½®é¢æ¿ -->
                <div class="control-section">
                    <h3 onclick="toggleCollapse(this)">
                        âš™ï¸ å›¾è¡¨è®¾ç½®
                        <span class="collapse-arrow">â–¼</span>
                    </h3>
                    <div class="control-content active" id="chart-settings">
                        <!-- åŠ¨æ€ç”Ÿæˆå›¾è¡¨è®¾ç½® -->
                    </div>
                    <div class="validation-message" id="settings-validation"></div>
                    <button class="confirm-btn" id="settings-confirm-btn" onclick="confirmSettingsChanges()">âš™ï¸ ç¡®è®¤å›¾è¡¨è®¾ç½®</button>
                </div>

                <!-- æ•°æ®æ ‡è®°é¢æ¿ -->
                <div class="control-section">
                    <h3 onclick="toggleCollapse(this)">
                        ğŸ” æ•°æ®æ ‡è®°
                        <span class="collapse-arrow">â–¼</span>
                    </h3>
                    <div class="control-content active" id="marker-controls">
                        <!-- åŠ¨æ€ç”Ÿæˆæ ‡è®°è®¾ç½® -->
                    </div>
                    <div class="validation-message" id="marker-validation"></div>
                    <button class="confirm-btn" id="marker-confirm-btn" onclick="confirmMarkerChanges()">âœ… ç¡®è®¤æ ‡è®°è®¾ç½®</button>
                </div>
            </div>
            
            <div class="visualization-area">
                <div id="chart-container"></div>
                <div class="download-controls">
                    <button class="download-btn" onclick="downloadChart('png', event)">ğŸ“¥ ä¸‹è½½PNG</button>
                    <button class="download-btn" onclick="downloadChart('svg', event)">ğŸ“¥ ä¸‹è½½SVG</button>
                    <button class="download-btn" onclick="downloadChart('jpg', event)">ğŸ“¥ ä¸‹è½½JPG</button>
                    <button class="download-btn" onclick="resetChart()">ğŸ”„ é‡ç½®å›¾è¡¨</button>
                    <button class="download-btn" onclick="undoChanges()">â†©ï¸ æ’¤é”€ä¿®æ”¹</button>
                </div>
                
                <!-- å›¾è¡¨è¯´æ˜åŒºåŸŸ -->
                <div id="chart-explanation" class="chart-explanation-container">
                    <h3>ğŸ“‹ å›¾è¡¨è¯´æ˜</h3>
                    <div class="chart-explanation-content">
                        <div class="chart-explanation book-purchase">
                            <h4>ğŸ“š å›¾ä¹¦é‡‡è´­æƒ…å†µåˆ†æ</h4>
                            <p>æœ¬å›¾è¡¨å±•ç¤ºä¸¤ä¸ªåœ°åŒºå¯¹äº”ç±»å›¾ä¹¦çš„é‡‡è´­æ•°é‡å¯¹æ¯”ã€‚æ•°æ®æ˜¾ç¤ºï¼Œå°è¯´ç±»å›¾ä¹¦åœ¨ä¸¤åœ°é‡‡è´­é‡å‡æœ€é«˜ï¼Œåæ˜ å‡ºæ–‡å­¦ä½œå“çš„æ™®éå—æ¬¢è¿ç¨‹åº¦ã€‚ç§‘æŠ€ç±»å›¾ä¹¦é‡‡è´­é‡ä¹Ÿç›¸å¯¹è¾ƒé«˜ï¼Œä½“ç°äººä»¬å¯¹çŸ¥è¯†ç±»ä¹¦ç±çš„éœ€æ±‚ã€‚æ•°æ®æ¥æºä¸ºæ¨¡æ‹Ÿçš„å›¾ä¹¦é‡‡è´­è®°å½•ï¼Œæ—¨åœ¨åˆ†æä¸åŒåœ°åŒºçš„é˜…è¯»åå¥½å·®å¼‚ã€‚</p>
                        </div>
                        <div class="chart-explanation exchange-rate" style="display: none;">
                            <h4>ğŸ’± ç¾å…ƒ/äººæ°‘å¸æ±‡ç‡èµ°åŠ¿</h4>
                            <p>æœ¬æŠ˜çº¿å›¾å¯¹æ¯”2017å¹´7æœˆå’Œ2019å¹´7æœˆç¾å…ƒå…‘äººæ°‘å¸çš„æ±‡ç‡å˜åŒ–ã€‚2017å¹´æ±‡ç‡ç›¸å¯¹ç¨³å®šåœ¨6.78-6.81åŒºé—´ï¼Œ2019å¹´åˆ™æ³¢åŠ¨è¾ƒå¤§ï¼ˆ6.86-6.89ï¼‰ã€‚æ•°æ®æ¥æºäºå†å²å¤–æ±‡å¸‚åœºè®°å½•ï¼Œæ˜¾ç¤ºæ±‡ç‡å—å®è§‚ç»æµå› ç´ å½±å“æ˜æ˜¾ï¼Œä¸ºå›½é™…è´¸æ˜“å’ŒæŠ•èµ„å†³ç­–æä¾›å‚è€ƒä¾æ®ã€‚</p>
                        </div>
                        <div class="chart-explanation sales" style="display: none;">
                            <h4>ğŸ“ˆ å­£åº¦äº§å“é”€å”®åˆ†æ</h4>
                            <p>æœ¬å›¾è¡¨å±•ç¤ºä¸‰ç§äº§å“åœ¨å››ä¸ªå­£åº¦çš„é”€å”®é¢å˜åŒ–è¶‹åŠ¿ã€‚äº§å“Aå¢é•¿è¿…é€Ÿï¼Œåœ¨ç¬¬3å­£åº¦è¾¾åˆ°å³°å€¼ï¼›äº§å“Bç¨³æ­¥å¢é•¿ï¼›äº§å“CåŸºæ•°è™½å°ä½†å¢å¹…æ˜æ˜¾ã€‚æ•°æ®æ˜¾ç¤ºå­£èŠ‚æ€§æ¶ˆè´¹ç‰¹å¾ï¼Œæœ‰åŠ©äºä¼ä¸šåˆ¶å®šè¥é”€ç­–ç•¥å’Œåº“å­˜ç®¡ç†ã€‚æ•°æ®æ¨¡æ‹ŸçœŸå®é”€å”®åœºæ™¯ï¼Œåæ˜ å¸‚åœºåŠ¨æ€ã€‚</p>
                        </div>
                        <div class="chart-explanation temperature" style="display: none;">
                            <h4>ğŸŒ¡ï¸ 15å¤©æ¸©åº¦å˜åŒ–è¶‹åŠ¿</h4>
                            <p>æœ¬å›¾è¡¨å±•ç¤ºæœªæ¥15å¤©æœ€é«˜å’Œæœ€ä½æ°”æ¸©çš„å˜åŒ–æƒ…å†µã€‚æ¸©åº¦æ³¢åŠ¨æ˜æ˜¾ï¼Œç¬¬11-13å¤©å‡ºç°æœ€ä½å€¼ï¼Œéšåå›å‡ã€‚æ•°æ®æ¥æºäºæ°”è±¡é¢„æŠ¥æ¨¡æ‹Ÿï¼Œå¸®åŠ©äººä»¬äº†è§£å¤©æ°”å˜åŒ–è§„å¾‹ï¼Œä¸ºå‡ºè¡Œã€å†œä¸šå’Œèƒ½æºè§„åˆ’æä¾›å‚è€ƒã€‚æ¸©å·®å˜åŒ–æ˜¾ç¤ºæ°”å€™å˜åŒ–çš„ä¸ç¡®å®šæ€§ã€‚</p>
                        </div>
                        <div class="chart-explanation snowflake" style="display: none;">
                            <h4>â„ï¸ ç§‘èµ«é›ªèŠ±åˆ†å½¢å›¾æ¡ˆ</h4>
                            <p>ç§‘èµ«é›ªèŠ±æ˜¯è‘—åçš„åˆ†å½¢å‡ ä½•å›¾å½¢ï¼Œé€šè¿‡è¿­ä»£ç®—æ³•ç”Ÿæˆã€‚æœ¬å›¾è¡¨å±•ç¤ºäºŒé˜¶ç§‘èµ«é›ªèŠ±ï¼Œå…·æœ‰è‡ªç›¸ä¼¼æ€§å’Œæ— é™å‘¨é•¿ç‰¹æ€§ã€‚åˆ†å½¢å‡ ä½•åœ¨è‡ªç„¶ç•Œä¸­å¹¿æ³›å­˜åœ¨ï¼Œå¦‚æµ·å²¸çº¿ã€äº‘æœµç­‰ã€‚è¿™ç§æ•°å­¦å¯è§†åŒ–æœ‰åŠ©äºç†è§£å¤æ‚ç³»ç»Ÿçš„ç»“æ„è§„å¾‹ï¼Œåœ¨è®¡ç®—æœºå›¾å½¢å­¦å’Œè‰ºæœ¯è®¾è®¡ä¸­æœ‰é‡è¦åº”ç”¨ã€‚</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ================================
        // æ ¸å¿ƒå›¾è¡¨ç®¡ç†å™¨ - æ¨¡å—åŒ–è®¾è®¡
        // ================================
        class ChartManager {
            constructor() {
                this.currentChart = 'book-purchase';
                this.modificationHistory = [];
                this.originalData = this.initializeChartData();
                this.chartData = JSON.parse(JSON.stringify(this.originalData));
                this.performance = { startTime: 0, endTime: 0 };
                this.cache = new Map(); // ç¼“å­˜ä¼˜åŒ–
            }

            /**
             * åˆå§‹åŒ–å›¾è¡¨æ•°æ® - ä¸IPython Notebookå®Œå…¨ä¸€è‡´
             */
            initializeChartData() {
                return {
                    'book-purchase': {
                        type: 'bar',
                        title: 'åœ°åŒº1å’Œåœ°åŒº2å¯¹å„ç±»å›¾ä¹¦çš„é‡‡è´­æƒ…å†µ',
                        layout: { 
                            xaxis: { title: 'å›¾ä¹¦ç§ç±»' }, 
                            yaxis: { title: 'é‡‡è´­æ•°é‡(æœ¬)' },
                            grid: true,
                            legend: { orientation: 'top' }
                        },
                        data: {
                            categories: ['å®¶åº­', 'å°è¯´', 'å¿ƒç†', 'ç§‘æŠ€', 'å„¿ç«¥'],
                            series: [
                                { name: 'åœ°åŒº1', values: [1200, 2400, 1800, 2200, 1600], color: '#FFCC00' },
                                { name: 'åœ°åŒº2', values: [1050, 2100, 1300, 1600, 1340], color: '#B0C4DE' }
                            ]
                        }
                    },
                    'exchange-rate': {
                        type: 'line',
                        title: '2017å¹´7æœˆä¸2019å¹´7æœˆç¾å…ƒ/äººæ°‘å¸æ±‡ç‡èµ°åŠ¿',
                        layout: { 
                            xaxis: { title: 'æ—¥æœŸ' }, 
                            yaxis: { title: 'æ±‡ç‡' },
                            grid: true,
                            legend: { orientation: 'top' }
                        },
                        data: {
                            categories: [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 17, 18, 19, 24, 25, 26, 31],
                            series: [
                                { 
                                    name: '2017å¹´7æœˆç¾å…ƒ/äººæ°‘å¸æ±‡ç‡', 
                                    values: [6.8007, 6.8007, 6.8015, 6.8015, 6.8060, 6.8060, 6.8060, 6.8036, 6.8025, 6.7877, 6.7835, 6.7758, 6.7700, 6.7463, 6.7519, 6.7511, 6.7511, 6.7539, 6.7265],
                                    color: '#006374',
                                    linestyle: 'solid'
                                },
                                { 
                                    name: '2019å¹´7æœˆç¾å…ƒ/äººæ°‘å¸æ±‡ç‡', 
                                    values: [6.8640, 6.8705, 6.8697, 6.8697, 6.8697, 6.8881, 6.8853, 6.8856, 6.8677, 6.8662, 6.8662, 6.8662, 6.8827, 6.8761, 6.8635, 6.8860, 6.8737, 6.8796, 6.8841],
                                    color: '#8a2e76',
                                    linestyle: 'dashed'
                                }
                            ]
                        }
                    },
                    'sales': {
                        type: 'line',
                        title: 'ä¸åŒäº§å“å„å­£åº¦çš„é”€å”®é¢',
                        layout: { 
                            xaxis: { title: 'å­£åº¦' }, 
                            yaxis: { title: 'é”€å”®é¢(ä¸‡å…ƒ)' },
                            grid: true,
                            legend: { orientation: 'top' }
                        },
                        data: {
                            categories: ['ç¬¬1å­£åº¦', 'ç¬¬2å­£åº¦', 'ç¬¬3å­£åº¦', 'ç¬¬4å­£åº¦'],
                            series: [
                                { name: 'äº§å“A', values: [2144, 4617, 7674, 6666], color: '#1f77b4', marker: 'diamond' },
                                { name: 'äº§å“B', values: [853, 1214, 2414, 4409], color: '#ff7f0e', marker: 'triangle-up' },
                                { name: 'äº§å“C', values: [153, 155, 292, 680], color: '#2ca02c', marker: 'square' }
                            ]
                        }
                    },
                    'temperature': {
                        type: 'line',
                        title: 'æœªæ¥15å¤©çš„æœ€é«˜æ°”æ¸©å’Œæœ€ä½æ°”æ¸©èµ°åŠ¿',
                        layout: { 
                            xaxis: { title: 'æ—¥æœŸ' }, 
                            yaxis: { title: 'æ¸©åº¦(Â°C)' },
                            grid: true,
                            legend: { orientation: 'top' }
                        },
                        data: {
                            categories: Array.from({length: 15}, (_, i) => i + 4),
                            series: [
                                { name: 'æœ€é«˜æ¸©åº¦', values: [32, 33, 34, 34, 33, 31, 30, 29, 30, 29, 26, 23, 21, 25, 31], color: '#e74c3c', marker: 'circle' },
                                { name: 'æœ€ä½æ¸©åº¦', values: [19, 19, 20, 22, 22, 21, 22, 16, 18, 18, 17, 14, 15, 16, 16], color: '#3498db', marker: 'circle' }
                            ]
                        }
                    },
                    'snowflake': {
                        type: 'snowflake',
                        title: 'ç§‘èµ«é›ªèŠ±åˆ†å½¢å›¾æ¡ˆ',
                        layout: { 
                            xaxis: { title: '', showgrid: false, zeroline: false }, 
                            yaxis: { title: '', showgrid: false, zeroline: false },
                            showlegend: false
                        },
                        data: {
                            order: 3,
                            scale: 100,
                            color: '#3498db',
                            fillColor: 'rgba(52, 152, 219, 0.3)'
                        }
                    }
                };
            }

            /**
             * æ€§èƒ½ç›‘æ§ - å¼€å§‹è®¡æ—¶
             */
            startPerformanceMonitoring() {
                this.performance.startTime = performance.now();
            }

            /**
             * æ€§èƒ½ç›‘æ§ - ç»“æŸè®¡æ—¶
             */
            endPerformanceMonitoring() {
                this.performance.endTime = performance.now();
                const duration = this.performance.endTime - this.performance.startTime;
                console.log(`å›¾è¡¨æ¸²æŸ“è€—æ—¶: ${duration.toFixed(2)}ms`);
                return duration;
            }

            /**
             * ç¼“å­˜ä¼˜åŒ– - æ£€æŸ¥ç¼“å­˜
             */
            getCache(key) {
                return this.cache.get(key);
            }

            /**
             * ç¼“å­˜ä¼˜åŒ– - è®¾ç½®ç¼“å­˜
             */
            setCache(key, value) {
                this.cache.set(key, value);
            }
        }

        // ================================
        // å…¨å±€å˜é‡å’ŒçŠ¶æ€ç®¡ç†
        // ================================
        let chartManager = new ChartManager();
        let tempData = {};
        let tempColors = {};
        let tempSettings = {};

        // ================================
        // æ ¸å¿ƒäº¤äº’åŠŸèƒ½å®ç°
        // ================================

        /**
         * åˆ‡æ¢å›¾è¡¨ç±»å‹
         */
        function switchChart(chartType) {
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.chart-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // åˆ‡æ¢å›¾è¡¨
            chartManager.currentChart = chartType;
            
            // æ›´æ–°å›¾è¡¨è¯´æ˜
            updateChartExplanation();
            
            initializePage();
        }

        /**
         * åˆå§‹åŒ–é¡µé¢
         */
        function initializePage() {
            // ç¡®ä¿æ‰€æœ‰æ§åˆ¶é¢æ¿éƒ½å±•å¼€
            document.querySelectorAll('.control-section').forEach(section => {
                section.classList.add('expanded');
                const content = section.querySelector('.control-content');
                const arrow = section.querySelector('.collapse-arrow');
                if (content) {
                    content.classList.add('active');
                    content.style.maxHeight = '2000px';
                }
                if (arrow) {
                    arrow.textContent = 'â–²';
                }
            });
            
            updateDataEditor();
            updateColorControls();
            updateChartSettings();
            updateMarkerControls();
            updateChartExplanation();
            renderChart();
        }

        /**
         * æ›´æ–°æ•°æ®ç¼–è¾‘å™¨
         */
        function updateDataEditor() {
            const editor = document.getElementById('data-editor');
            const chart = chartManager.chartData[chartManager.currentChart];
            
            if (chart.type === 'snowflake') {
                // ç§‘èµ«é›ªèŠ±ç‰¹æ®Šå¤„ç†
                editor.innerHTML = `
                    <div class="control-item">
                        <label>åˆ†å½¢é˜¶æ•°:</label>
                        <input type="number" value="${chart.data.order}" min="0" max="5" 
                               onchange="previewDataChange('order', this.value)">
                    </div>
                    <div class="control-item">
                        <label>ç¼©æ”¾æ¯”ä¾‹:</label>
                        <input type="number" value="${chart.data.scale}" min="10" max="200" 
                               onchange="previewDataChange('scale', this.value)">
                    </div>
                `;
            } else {
                // å¸¸è§„å›¾è¡¨æ•°æ®ç¼–è¾‘
                let html = `<table class="data-table">
                    <thead>
                        <tr>
                            <th>ç±»åˆ«</th>`;
                
                chart.data.series.forEach(series => {
                    html += `<th>${series.name}</th>`;
                });
                
                html += `</tr></thead><tbody>`;
                
                chart.data.categories.forEach((category, index) => {
                    html += `<tr>
                        <td><strong>${category}</strong></td>`;
                    
                    chart.data.series.forEach(series => {
                        html += `<td>
                            <input type="number" value="${series.values[index]}" 
                                   onchange="previewDataChange('${series.name}', ${index}, this.value)">
                        </td>`;
                    });
                    
                    html += `</tr>`;
                });
                
                html += `</tbody></table>`;
                editor.innerHTML = html;
            }
        }

        /**
         * æ›´æ–°é¢œè‰²æ§ä»¶
         */
        function updateColorControls() {
            const controls = document.getElementById('color-controls');
            const chart = chartManager.chartData[chartManager.currentChart];
            
            if (chart.type === 'snowflake') {
                controls.innerHTML = `
                    <div class="control-item">
                        <label>è¾¹æ¡†é¢œè‰²:</label>
                        <input type="color" value="${chart.data.color}" 
                               onchange="previewColorChange('border', this.value)">
                    </div>
                    <div class="control-item">
                        <label>å¡«å……é¢œè‰²:</label>
                        <input type="color" value="${chart.data.fillColor}" 
                               onchange="previewColorChange('fill', this.value)">
                    </div>
                `;
            } else {
                let html = '<div class="control-item"><label>ç³»åˆ—é¢œè‰²é…ç½®:</label></div>';
                
                chart.data.series.forEach((series, index) => {
                    html += `
                    <div class="control-item">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div style="width: 20px; height: 20px; background: ${series.color}; border-radius: 3px;"></div>
                            <span>${series.name}</span>
                            <input type="color" value="${series.color}" 
                                   onchange="previewColorChange(${index}, this.value)">
                        </div>
                    </div>`;
                });
                
                controls.innerHTML = html;
            }
        }

        /**
         * æ›´æ–°å›¾è¡¨è®¾ç½®
         */
        function updateChartSettings() {
            const settings = document.getElementById('chart-settings');
            const chart = chartManager.chartData[chartManager.currentChart];
            
            let html = `
                <div class="control-item">
                    <label>å›¾è¡¨æ ‡é¢˜:</label>
                    <input type="text" value="${chart.title}" 
                           onchange="previewSettingsChange('title', this.value)">
                </div>
            `;
            
            // æ·»åŠ ç‰¹å®šäºå›¾è¡¨ç±»å‹çš„è®¾ç½®
            if (chart.type === 'line') {
                html += `
                <div class="control-item">
                    <label>çº¿æ¡æ ·å¼:</label>
                    <select onchange="previewSettingsChange('lineStyle', this.value)" id="lineStyleSelect" style="position: relative;">
                        <option value="solid">â”â” å®çº¿</option>
                        <option value="dashed">- - - è™šçº¿</option>
                        <option value="dotted">Â· Â· Â· ç‚¹çº¿</option>
                    </select>
                </div>
                `;
            }
            
            settings.innerHTML = html;
        }

        /**
         * æ›´æ–°æ ‡è®°æ§ä»¶
         */
        function updateMarkerControls() {
            const controls = document.getElementById('marker-controls');
            const chart = chartManager.chartData[chartManager.currentChart];
            
            if (chart.type !== 'line') {
                controls.innerHTML = '<div class="control-item"><p style="color: var(--text-secondary); font-size: 14px;">ğŸ“Š è¯¥å›¾è¡¨ç±»å‹ä¸æ”¯æŒæ•°æ®æ ‡è®°åŠŸèƒ½</p></div>';
                return;
            }
            
            let html = '<div class="control-item"><label>æ•°æ®æ ‡è®°é…ç½®:</label></div>';
            
            chart.data.series.forEach((series, index) => {
                const markerType = series.marker || 'circle';
                const markerSize = series.markerSize || 8;
                const markerColor = series.markerColor || series.color;
                
                html += `
                <div class="control-item">
                    <div style="border: 1px solid var(--border-color); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <div style="width: 20px; height: 20px; background: ${series.color}; border-radius: 3px;"></div>
                            <strong>${series.name}</strong>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div>
                                <label style="font-size: 12px;">æ ‡è®°ç±»å‹:</label>
                                <select onchange="previewMarkerChange(${index}, 'type', this.value)" style="width: 100%; padding: 4px; font-size: 12px;">
                                    <option value="circle" ${markerType === 'circle' ? 'selected' : ''}>â— åœ†å½¢</option>
                                    <option value="square" ${markerType === 'square' ? 'selected' : ''}>â–  æ–¹å½¢</option>
                                    <option value="diamond" ${markerType === 'diamond' ? 'selected' : ''}>â—† è±å½¢</option>
                                    <option value="triangle-up" ${markerType === 'triangle-up' ? 'selected' : ''}>â–² ä¸Šä¸‰è§’</option>
                                    <option value="triangle-down" ${markerType === 'triangle-down' ? 'selected' : ''}>â–¼ ä¸‹ä¸‰è§’</option>
                                    <option value="star" ${markerType === 'star' ? 'selected' : ''}>â˜… æ˜Ÿå½¢</option>
                                    <option value="x" ${markerType === 'x' ? 'selected' : ''}>âœ• å‰å½¢</option>
                                    <option value="none" ${markerType === 'none' ? 'selected' : ''}>æ— æ ‡è®°</option>
                                </select>
                            </div>
                            
                            <div>
                                <label style="font-size: 12px;">æ ‡è®°å¤§å°:</label>
                                <input type="range" min="4" max="20" value="${markerSize}" 
                                       onchange="previewMarkerChange(${index}, 'size', this.value)" 
                                       style="width: 100%;">
                                <div class="marker-size-display" style="text-align: center; font-size: 11px; color: var(--text-secondary);">${markerSize}px</div>
                            </div>
                        </div>
                        
                        <div style="margin-top: 10px;">
                            <label style="font-size: 12px;">æ ‡è®°é¢œè‰²:</label>
                            <input type="color" value="${markerColor}" 
                                   onchange="previewMarkerChange(${index}, 'color', this.value)" 
                                   style="width: 100%; height: 35px;">
                        </div>
                    </div>
                </div>
                `;
            });
            
            controls.innerHTML = html;
        }

        /**
         * æ›´æ–°å›¾è¡¨è¯´æ˜
         */
        function updateChartExplanation() {
            const explanationContainer = document.getElementById('chart-explanation');
            if (!explanationContainer) return;
            
            // è·å–æ‰€æœ‰å›¾è¡¨è¯´æ˜å…ƒç´ 
            const explanations = {
                'book-purchase': explanationContainer.querySelector('.chart-explanation.book-purchase'),
                'exchange-rate': explanationContainer.querySelector('.chart-explanation.exchange-rate'),
                'sales': explanationContainer.querySelector('.chart-explanation.sales'),
                'temperature': explanationContainer.querySelector('.chart-explanation.temperature'),
                'snowflake': explanationContainer.querySelector('.chart-explanation.snowflake')
            };
            
            // éšè—æ‰€æœ‰è¯´æ˜
            Object.values(explanations).forEach(explanation => {
                if (explanation) {
                    explanation.style.display = 'none';
                }
            });
            
            // æ˜¾ç¤ºå½“å‰å›¾è¡¨çš„è¯´æ˜
            const currentExplanation = explanations[chartManager.currentChart];
            if (currentExplanation) {
                currentExplanation.style.display = 'block';
            }
        }

        /**
         * é¢„è§ˆæ•°æ®ä¿®æ”¹
         */
        function previewDataChange(...args) {
            if (!tempData[chartManager.currentChart]) {
                tempData[chartManager.currentChart] = {};
            }
            
            const chart = chartManager.currentChart;
            
            if (args.length === 2) {
                // ç§‘èµ«é›ªèŠ±å‚æ•°
                const [key, value] = args;
                tempData[chart][key] = parseFloat(value);
            } else {
                // å¸¸è§„æ•°æ®ä¿®æ”¹
                const [seriesName, index, value] = args;
                if (!tempData[chart][seriesName]) {
                    tempData[chart][seriesName] = {};
                }
                tempData[chart][seriesName][index] = parseFloat(value);
                
                // éªŒè¯æ•°æ®æœ‰æ•ˆæ€§
                const numValue = parseFloat(value);
                if (isNaN(numValue)) {
                    showValidationMessage('data-validation', 'è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—', 'error');
                    return;
                }
                
                if (numValue < 0) {
                    showValidationMessage('data-validation', 'æ•°å€¼ä¸èƒ½ä¸ºè´Ÿæ•°', 'warning');
                } else {
                    showValidationMessage('data-validation', 'æ•°æ®ä¿®æ”¹å·²ä¿å­˜ä¸ºé¢„è§ˆ', 'success');
                }
            }
            
            // å®æ—¶é¢„è§ˆ - ä½¿ç”¨é˜²æŠ–ä¼˜åŒ–æ€§èƒ½
            clearTimeout(window.previewTimeout);
            window.previewTimeout = setTimeout(() => {
                renderChart(true);
            }, 200);
        }

        /**
         * é¢„è§ˆé¢œè‰²ä¿®æ”¹
         */
        function previewColorChange(...args) {
            if (!tempColors[chartManager.currentChart]) {
                tempColors[chartManager.currentChart] = {};
            }
            
            const chart = chartManager.currentChart;
            
            if (args.length === 2 && (args[0] === 'border' || args[0] === 'fill')) {
                // ç§‘èµ«é›ªèŠ±é¢œè‰²
                const [type, value] = args;
                tempColors[chart][type] = value;
                showValidationMessage('color-validation', `é¢œè‰²ä¿®æ”¹å·²ä¿å­˜ä¸ºé¢„è§ˆ`, 'success');
            } else {
                // å¸¸è§„é¢œè‰²ä¿®æ”¹
                const [seriesIndex, value] = args;
                tempColors[chart][seriesIndex] = value;
                showValidationMessage('color-validation', `é¢œè‰²ä¿®æ”¹å·²ä¿å­˜ä¸ºé¢„è§ˆ`, 'success');
            }
            
            // å®æ—¶é¢„è§ˆ - ä½¿ç”¨é˜²æŠ–ä¼˜åŒ–æ€§èƒ½å¹¶æ·»åŠ åŠ¨ç”»æ•ˆæœ
            clearTimeout(window.previewTimeout);
            window.previewTimeout = setTimeout(() => {
                // æ·»åŠ å¹³æ»‘è¿‡æ¸¡åŠ¨ç”»
                const chartContainer = document.getElementById('chart-container');
                if (chartContainer) {
                    chartContainer.style.transition = 'opacity 0.3s ease';
                    chartContainer.style.opacity = '0.7';
                }
                
                renderChart(true);
                
                // æ¢å¤ä¸é€æ˜åº¦
                setTimeout(() => {
                    if (chartContainer) {
                        chartContainer.style.opacity = '1';
                    }
                }, 300);
            }, 100);
        }

        /**
         * é¢„è§ˆè®¾ç½®ä¿®æ”¹
         */
        function previewSettingsChange(key, value) {
            if (!tempSettings[chartManager.currentChart]) {
                tempSettings[chartManager.currentChart] = {};
            }
            
            tempSettings[chartManager.currentChart][key] = value;
            showValidationMessage('settings-validation', `è®¾ç½®ä¿®æ”¹å·²ä¿å­˜ä¸ºé¢„è§ˆ`, 'success');
            
            // å®æ—¶é¢„è§ˆ - ä½¿ç”¨é˜²æŠ–ä¼˜åŒ–æ€§èƒ½å¹¶æ·»åŠ åŠ¨ç”»æ•ˆæœ
            clearTimeout(window.previewTimeout);
            window.previewTimeout = setTimeout(() => {
                // æ·»åŠ å¹³æ»‘è¿‡æ¸¡åŠ¨ç”»
                const chartContainer = document.getElementById('chart-container');
                if (chartContainer) {
                    chartContainer.style.transition = 'opacity 0.3s ease';
                    chartContainer.style.opacity = '0.7';
                }
                
                renderChart(true);
                
                // æ¢å¤ä¸é€æ˜åº¦
                setTimeout(() => {
                    if (chartContainer) {
                        chartContainer.style.opacity = '1';
                    }
                }, 300);
            }, 100);
        }

        /**
         * é¢„è§ˆæ ‡è®°ä¿®æ”¹
         */
        function previewMarkerChange(seriesIndex, property, value) {
            if (!tempSettings[chartManager.currentChart]) {
                tempSettings[chartManager.currentChart] = {};
            }
            
            if (!tempSettings[chartManager.currentChart].markers) {
                tempSettings[chartManager.currentChart].markers = {};
            }
            
            if (!tempSettings[chartManager.currentChart].markers[seriesIndex]) {
                tempSettings[chartManager.currentChart].markers[seriesIndex] = {};
            }
            
            tempSettings[chartManager.currentChart].markers[seriesIndex][property] = value;
            
            // æ›´æ–°æ»‘å—æ˜¾ç¤ºå€¼
            if (property === 'size') {
                const sizeDisplay = document.querySelector(`[data-series-index="${seriesIndex}"] .marker-size-display`);
                if (sizeDisplay) {
                    sizeDisplay.textContent = `${value}px`;
                }
            }
            
            showValidationMessage('marker-validation', `æ ‡è®°ä¿®æ”¹å·²ä¿å­˜ä¸ºé¢„è§ˆ`, 'success');
            
            // å®æ—¶é¢„è§ˆ - ä½¿ç”¨é˜²æŠ–ä¼˜åŒ–æ€§èƒ½
            clearTimeout(window.markerPreviewTimeout);
            window.markerPreviewTimeout = setTimeout(() => {
                renderChart(true);
            }, 200);
        }

        /**
         * ç¡®è®¤æ ‡è®°ä¿®æ”¹
         */
        function confirmMarkerChanges() {
            const chart = chartManager.currentChart;
            if (!tempSettings[chart] || !tempSettings[chart].markers) {
                showValidationMessage('marker-validation', 'æ²¡æœ‰éœ€è¦ä¿å­˜çš„æ ‡è®°ä¿®æ”¹', 'warning');
                return;
            }
            
            const btn = document.getElementById('marker-confirm-btn');
            btn.classList.add('loading');
            btn.textContent = 'â³ ä¿å­˜ä¸­...';
            
            // åº”ç”¨æ ‡è®°ä¿®æ”¹
            Object.keys(tempSettings[chart].markers).forEach(seriesIndex => {
                const markerSettings = tempSettings[chart].markers[seriesIndex];
                const series = chartManager.chartData[chart].data.series[seriesIndex];
                
                Object.keys(markerSettings).forEach(property => {
                    if (property === 'type') {
                        series.marker = markerSettings[property];
                    } else if (property === 'size') {
                        series.markerSize = parseInt(markerSettings[property]);
                    } else if (property === 'color') {
                        series.markerColor = markerSettings[property];
                    }
                });
            });
            
            // æ›´æ–°ä¿®æ”¹å†å²
            chartManager.modificationHistory.push({
                type: 'marker',
                chart: chart,
                timestamp: new Date(),
                description: 'ä¿®æ”¹æ•°æ®æ ‡è®°æ ·å¼'
            });
            
            // æ¸…é™¤ä¸´æ—¶æ ‡è®°è®¾ç½®
            delete tempSettings[chart].markers;
            
            setTimeout(() => {
                btn.classList.remove('loading');
                btn.classList.add('success');
                btn.textContent = 'âœ… æ ‡è®°å·²ä¿å­˜';
                
                showValidationMessage('marker-validation', 'æ ‡è®°è®¾ç½®å·²æˆåŠŸä¿å­˜ï¼', 'success');
                
                setTimeout(() => {
                    btn.classList.remove('success');
                    btn.textContent = 'âœ… ç¡®è®¤æ ‡è®°è®¾ç½®';
                    renderChart();
                }, 2000);
            }, 500);
        }

        /**
         * é¢„è§ˆæ ‡è®°ä¿®æ”¹
         */
        function previewMarkerChange(seriesIndex, property, value) {
            if (!tempSettings[chartManager.currentChart]) {
                tempSettings[chartManager.currentChart] = {};
            }
            
            if (!tempSettings[chartManager.currentChart].markers) {
                tempSettings[chartManager.currentChart].markers = {};
            }
            
            if (!tempSettings[chartManager.currentChart].markers[seriesIndex]) {
                tempSettings[chartManager.currentChart].markers[seriesIndex] = {};
            }
            
            tempSettings[chartManager.currentChart].markers[seriesIndex][property] = value;
            
            // æ›´æ–°æ»‘å—æ˜¾ç¤ºå€¼
            if (property === 'size') {
                const sizeDisplay = document.querySelector(`[data-series-index="${seriesIndex}"] .marker-size-display`);
                if (sizeDisplay) {
                    sizeDisplay.textContent = `${value}px`;
                }
            }
            
            showValidationMessage('marker-validation', `æ ‡è®°ä¿®æ”¹å·²ä¿å­˜ä¸ºé¢„è§ˆ`, 'success');
            
            // å®æ—¶é¢„è§ˆ - ä½¿ç”¨é˜²æŠ–ä¼˜åŒ–æ€§èƒ½
            clearTimeout(window.markerPreviewTimeout);
            window.markerPreviewTimeout = setTimeout(() => {
                renderChart(true);
            }, 200);
        }

        /**
         * ç¡®è®¤æ ‡è®°ä¿®æ”¹
         */
        function confirmMarkerChanges() {
            const chart = chartManager.currentChart;
            if (!tempSettings[chart] || !tempSettings[chart].markers) {
                showValidationMessage('marker-validation', 'æ²¡æœ‰éœ€è¦ä¿å­˜çš„æ ‡è®°ä¿®æ”¹', 'warning');
                return;
            }
            
            const btn = document.getElementById('marker-confirm-btn');
            btn.classList.add('loading');
            btn.textContent = 'â³ ä¿å­˜ä¸­...';
            
            // åº”ç”¨æ ‡è®°ä¿®æ”¹
            Object.keys(tempSettings[chart].markers).forEach(seriesIndex => {
                const markerSettings = tempSettings[chart].markers[seriesIndex];
                const series = chartManager.chartData[chart].data.series[seriesIndex];
                
                Object.keys(markerSettings).forEach(property => {
                    if (property === 'type') {
                        series.marker = markerSettings[property];
                    } else if (property === 'size') {
                        series.markerSize = parseInt(markerSettings[property]);
                    } else if (property === 'color') {
                        series.markerColor = markerSettings[property];
                    }
                });
            });
            
            // æ›´æ–°ä¿®æ”¹å†å²
            chartManager.modificationHistory.push({
                type: 'marker',
                chart: chart,
                timestamp: new Date(),
                description: 'ä¿®æ”¹æ•°æ®æ ‡è®°æ ·å¼'
            });
            
            // æ¸…é™¤ä¸´æ—¶æ ‡è®°è®¾ç½®
            delete tempSettings[chart].markers;
            
            setTimeout(() => {
                btn.classList.remove('loading');
                btn.classList.add('success');
                btn.textContent = 'âœ… æ ‡è®°å·²ä¿å­˜';
                
                showValidationMessage('marker-validation', 'æ ‡è®°è®¾ç½®å·²æˆåŠŸä¿å­˜ï¼', 'success');
                
                setTimeout(() => {
                    btn.classList.remove('success');
                    btn.textContent = 'âœ… ç¡®è®¤æ ‡è®°è®¾ç½®';
                    renderChart();
                }, 2000);
            }, 500);
        }

        /**
         * æ¸²æŸ“å›¾è¡¨ - æ ¸å¿ƒæ¸²æŸ“å‡½æ•°
         */
        function renderChart(isPreview = false) {
            chartManager.startPerformanceMonitoring();
            
            const chart = chartManager.chartData[chartManager.currentChart];
            const traces = [];

            // åº”ç”¨ä¸´æ—¶ä¿®æ”¹ï¼ˆé¢„è§ˆæ¨¡å¼ï¼‰
            let currentData = JSON.parse(JSON.stringify(chart.data));
            let currentLayout = { ...chart.layout };
            let currentTitle = chart.title;
            
            if (isPreview) {
                // åˆå¹¶ä¸´æ—¶æ•°æ®
                if (tempData[chartManager.currentChart]) {
                    if (chart.type === 'snowflake') {
                        Object.keys(tempData[chartManager.currentChart]).forEach(key => {
                            currentData[key] = tempData[chartManager.currentChart][key];
                        });
                    } else {
                        Object.keys(tempData[chartManager.currentChart]).forEach(seriesName => {
                            const series = currentData.series.find(s => s.name === seriesName);
                            if (series) {
                                Object.keys(tempData[chartManager.currentChart][seriesName]).forEach(index => {
                                    series.values[index] = tempData[chartManager.currentChart][seriesName][index];
                                });
                            }
                        });
                    }
                }
                
                // åˆå¹¶ä¸´æ—¶é¢œè‰²
                if (tempColors[chartManager.currentChart]) {
                    if (chart.type === 'snowflake') {
                        Object.keys(tempColors[chartManager.currentChart]).forEach(key => {
                            currentData[key] = tempColors[chartManager.currentChart][key];
                        });
                    } else {
                        Object.keys(tempColors[chartManager.currentChart]).forEach(seriesIndex => {
                            if (currentData.series[seriesIndex]) {
                                currentData.series[seriesIndex].color = tempColors[chartManager.currentChart][seriesIndex];
                            }
                        });
                    }
                }
                
                // åˆå¹¶ä¸´æ—¶è®¾ç½®
                if (tempSettings[chartManager.currentChart]) {
                    Object.keys(tempSettings[chartManager.currentChart]).forEach(key => {
                        const value = tempSettings[chartManager.currentChart][key];
                        if (key === 'title') {
                            currentTitle = value;

                        } else if (key === 'lineStyle') {
                            // å¤„ç†çº¿æ¡æ ·å¼
                            currentData.series.forEach(series => {
                                if (series.line) {
                                    series.line.dash = getLineStyleDash(value);
                                }
                            });
                        }
                    });
                }
            }

            // æ ¹æ®å›¾è¡¨ç±»å‹ç”Ÿæˆè½¨è¿¹
            if (chart.type === 'bar') {
                currentData.series.forEach(series => {
                    traces.push({
                        x: currentData.categories,
                        y: series.values,
                        name: series.name,
                        type: 'bar',
                        marker: { color: series.color }
                    });
                });
            } else if (chart.type === 'line') {
                currentData.series.forEach(series => {
                    const lineStyle = getLineStyleDash(series.linestyle || 'solid');
                    
                    // å¤„ç†æ ‡è®°è®¾ç½®
                    let markerType = series.marker || 'circle';
                    let markerSize = series.markerSize || 8;
                    let markerColor = series.markerColor || series.color;
                    
                    // åº”ç”¨é¢„è§ˆæ ‡è®°è®¾ç½®
                    if (isPreview && tempSettings[chartManager.currentChart] && 
                        tempSettings[chartManager.currentChart].markers) {
                        const markerSettings = tempSettings[chartManager.currentChart].markers[currentData.series.indexOf(series)];
                        if (markerSettings) {
                            if (markerSettings.type) {
                                markerType = markerSettings.type;
                            }
                            if (markerSettings.size) {
                                markerSize = parseInt(markerSettings.size);
                            }
                            if (markerSettings.color) {
                                markerColor = markerSettings.color;
                            }
                        }
                    }
                    
                    // æ ¹æ®æ ‡è®°ç±»å‹å†³å®šæ˜¯å¦æ˜¾ç¤ºæ ‡è®°
                    const mode = markerType === 'none' ? 'lines' : 'lines+markers';
                    
                    traces.push({
                        x: currentData.categories,
                        y: series.values,
                        name: series.name,
                        type: 'scatter',
                        mode: mode,
                        line: { 
                            color: series.color, 
                            width: 3,
                            dash: lineStyle
                        },
                        marker: markerType === 'none' ? undefined : {
                            symbol: markerType,
                            color: markerColor,
                            size: markerSize,
                            line: {
                                color: '#ffffff',
                                width: 1
                            }
                        }
                    });
                });
            } else if (chart.type === 'snowflake') {
                // ç§‘èµ«é›ªèŠ±æ¸²æŸ“
                const snowflake = kochSnowflake(currentData.order, currentData.scale);
                traces.push({
                    x: snowflake.x,
                    y: snowflake.y,
                    type: 'scatter',
                    mode: 'lines',
                    fill: 'toself',
                    line: { color: currentData.color, width: 3 },
                    fillcolor: currentData.fillColor
                });
            }

            // å¸ƒå±€é…ç½®
            const layout = {
                title: currentTitle,
                xaxis: currentLayout.xaxis,
                yaxis: currentLayout.yaxis,
                showlegend: currentLayout.showlegend !== false,
                legend: currentLayout.legend,
                grid: currentLayout.grid ? { rows: 1, columns: 1, pattern: 'independent' } : undefined,
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                margin: { l: 60, r: 40, t: 60, b: 60 }
            };

            // æ¸…é™¤ç¼“å­˜ä»¥ç¡®ä¿å®æ—¶æ›´æ–°
            const cacheKey = JSON.stringify({ traces, layout, isPreview });
            
            Plotly.react('chart-container', traces, layout, { 
                responsive: true,
                displayModeBar: true 
            }).then(() => {
                chartManager.setCache(cacheKey, true);
                const duration = chartManager.endPerformanceMonitoring();
                
                if (isPreview) {
                    document.getElementById('chart-container').style.opacity = '0.8';
                    document.getElementById('chart-container').style.border = '2px dashed #3498db';
                } else {
                    document.getElementById('chart-container').style.opacity = '1';
                    document.getElementById('chart-container').style.border = '1px solid var(--border-color)';
                }
            }).catch(error => {
                console.error('å›¾è¡¨æ¸²æŸ“é”™è¯¯:', error);
                chartManager.endPerformanceMonitoring();
            });
        }

        /**
         * è·å–çº¿æ¡æ ·å¼
         */
        function getLineStyleDash(style) {
            switch (style) {
                case 'solid': return 'solid';
                case 'dashed': return 'dash';
                case 'dotted': return 'dot';
                default: return 'solid';
            }
        }

        // ================================
        // æµè§ˆå™¨å…¼å®¹æ€§ä¼˜åŒ–
        // ================================
        
        /**
         * æµè§ˆå™¨å…¼å®¹æ€§æ£€æŸ¥
         */
        function checkBrowserCompatibility() {
            const compatibility = {
                cssGrid: 'grid' in document.documentElement.style,
                cssFlexbox: 'flex' in document.documentElement.style,
                cssVariables: 'var' in document.documentElement.style,
                performance: 'performance' in window,
                requestAnimationFrame: 'requestAnimationFrame' in window,
                classList: 'classList' in document.createElement('div'),
                es6: typeof Symbol !== 'undefined' && typeof Map !== 'undefined'
            };
            
            // å¦‚æœç¼ºå°‘å…³é”®åŠŸèƒ½ï¼Œæä¾›é™çº§æ–¹æ¡ˆ
            if (!compatibility.cssGrid) {
                console.warn('æµè§ˆå™¨ä¸æ”¯æŒCSS Gridï¼Œå°†ä½¿ç”¨Flexboxå¸ƒå±€ä½œä¸ºé™çº§æ–¹æ¡ˆ');
                document.body.classList.add('grid-fallback');
            }
            
            if (!compatibility.cssVariables) {
                console.warn('æµè§ˆå™¨ä¸æ”¯æŒCSSå˜é‡ï¼Œå°†ä½¿ç”¨ä¼ ç»Ÿæ ·å¼');
                document.body.classList.add('css-vars-fallback');
            }
            
            return compatibility;
        }

        /**
         * è·¨æµè§ˆå™¨äº‹ä»¶ç›‘å¬å™¨
         */
        function addCrossBrowserEventListener(element, event, handler) {
            if (element.addEventListener) {
                element.addEventListener(event, handler, false);
            } else if (element.attachEvent) {
                element.attachEvent('on' + event, handler);
            } else {
                element['on' + event] = handler;
            }
        }

        /**
         * è·¨æµè§ˆå™¨åŠ¨ç”»å¸§
         */
        function requestAnimationFramePolyfill(callback) {
            return window.requestAnimationFrame || 
                   window.webkitRequestAnimationFrame || 
                   window.mozRequestAnimationFrame || 
                   function(callback) { window.setTimeout(callback, 1000 / 60); };
        }

        /**
         * å¹³æ»‘åŠ¨ç”»å‡½æ•°
         */
        function smoothAnimate(element, property, targetValue, duration = 300) {
            const startValue = parseFloat(getComputedStyle(element)[property]);
            const startTime = performance.now();
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°
                const eased = easeOutCubic(progress);
                const currentValue = startValue + (targetValue - startValue) * eased;
                
                element.style[property] = currentValue + (property === 'opacity' ? '' : 'px');
                
                if (progress < 1) {
                    requestAnimationFramePolyfill(animate);
                }
            }
            
            requestAnimationFramePolyfill(animate);
        }
        
        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }

        // ================================
        // æµè§ˆå™¨å…¼å®¹æ€§ä¼˜åŒ–
        // ================================
        
        /**
         * æµè§ˆå™¨å…¼å®¹æ€§æ£€æŸ¥
         */
        function checkBrowserCompatibility() {
            const compatibility = {
                cssGrid: 'grid' in document.documentElement.style,
                cssFlexbox: 'flex' in document.documentElement.style,
                cssVariables: 'var' in document.documentElement.style,
                performance: 'performance' in window,
                requestAnimationFrame: 'requestAnimationFrame' in window,
                classList: 'classList' in document.createElement('div'),
                es6: typeof Symbol !== 'undefined' && typeof Map !== 'undefined'
            };
            
            // å¦‚æœç¼ºå°‘å…³é”®åŠŸèƒ½ï¼Œæä¾›é™çº§æ–¹æ¡ˆ
            if (!compatibility.cssGrid) {
                console.warn('æµè§ˆå™¨ä¸æ”¯æŒCSS Gridï¼Œå°†ä½¿ç”¨Flexboxå¸ƒå±€ä½œä¸ºé™çº§æ–¹æ¡ˆ');
                document.body.classList.add('grid-fallback');
            }
            
            if (!compatibility.cssVariables) {
                console.warn('æµè§ˆå™¨ä¸æ”¯æŒCSSå˜é‡ï¼Œå°†ä½¿ç”¨ä¼ ç»Ÿæ ·å¼');
                document.body.classList.add('css-vars-fallback');
            }
            
            return compatibility;
        }

        /**
         * è·¨æµè§ˆå™¨äº‹ä»¶ç›‘å¬å™¨
         */
        function addCrossBrowserEventListener(element, event, handler) {
            if (element.addEventListener) {
                element.addEventListener(event, handler, false);
            } else if (element.attachEvent) {
                element.attachEvent('on' + event, handler);
            } else {
                element['on' + event] = handler;
            }
        }

        /**
         * è·¨æµè§ˆå™¨åŠ¨ç”»å¸§
         */
        function requestAnimationFramePolyfill(callback) {
            return window.requestAnimationFrame || 
                   window.webkitRequestAnimationFrame || 
                   window.mozRequestAnimationFrame || 
                   function(callback) { window.setTimeout(callback, 1000 / 60); };
        }

        /**
         * å¹³æ»‘åŠ¨ç”»å‡½æ•°
         */
        function smoothAnimate(element, property, targetValue, duration = 300) {
            const startValue = parseFloat(getComputedStyle(element)[property]);
            const startTime = performance.now();
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°
                const eased = easeOutCubic(progress);
                const currentValue = startValue + (targetValue - startValue) * eased;
                
                element.style[property] = currentValue + (property === 'opacity' ? '' : 'px');
                
                if (progress < 1) {
                    requestAnimationFramePolyfill(animate);
                }
            }
            
            requestAnimationFramePolyfill(animate);
        }
        
        function easeOutCubic(t) {
            return 1 - Math.pow(1 - t, 3);
        }

        // ================================
        // ç§‘èµ«é›ªèŠ±ç”Ÿæˆç®—æ³•
        // ================================
        function kochSnowflake(order, scale = 100) {
            function generateKochPoints(order) {
                if (order === 0) {
                    const size = scale * 2;
                    return [
                        { x: 0, y: -size / Math.sqrt(3) },
                        { x: -size / 2, y: size / (2 * Math.sqrt(3)) },
                        { x: size / 2, y: size / (2 * Math.sqrt(3)) }
                    ];
                }
                
                const basePoints = generateKochPoints(order - 1);
                const newPoints = [];
                
                for (let i = 0; i < basePoints.length; i++) {
                    const p1 = basePoints[i];
                    const p2 = basePoints[(i + 1) % basePoints.length];
                    
                    const dx = (p2.x - p1.x) / 3;
                    const dy = (p2.y - p1.y) / 3;
                    
                    const q1 = { x: p1.x + dx, y: p1.y + dy };
                    const q3 = { x: p1.x + 2 * dx, y: p1.y + 2 * dy };
                    
                    const angle = Math.atan2(dy, dx);
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const q2 = {
                        x: p1.x + dx + length * Math.cos(angle + Math.PI / 3),
                        y: p1.y + dy + length * Math.sin(angle + Math.PI / 3)
                    };
                    
                    newPoints.push(p1, q1, q2, q3);
                }
                
                return newPoints;
            }
            
            const points = generateKochPoints(order);
            return {
                x: points.map(p => p.x),
                y: points.map(p => p.y)
            };
        }

        // ================================
        // ç¡®è®¤ä¿®æ”¹åŠŸèƒ½
        // ================================

        function confirmDataChanges() {
            const btn = document.getElementById('data-confirm-btn');
            btn.classList.add('loading');
            
            setTimeout(() => {
                if (tempData[chartManager.currentChart]) {
                    // ä¿å­˜ä¿®æ”¹å†å²
                    chartManager.modificationHistory.push(
                        JSON.parse(JSON.stringify(chartManager.chartData[chartManager.currentChart]))
                    );
                    
                    // åº”ç”¨ä¸´æ—¶æ•°æ®
                    if (chartManager.currentChart === 'snowflake') {
                        Object.keys(tempData[chartManager.currentChart]).forEach(key => {
                            chartManager.chartData[chartManager.currentChart].data[key] = tempData[chartManager.currentChart][key];
                        });
                    } else {
                        Object.keys(tempData[chartManager.currentChart]).forEach(seriesName => {
                            Object.keys(tempData[chartManager.currentChart][seriesName]).forEach(index => {
                                const series = chartManager.chartData[chartManager.currentChart]
                                    .data.series.find(s => s.name === seriesName);
                                if (series) {
                                    series.values[index] = tempData[chartManager.currentChart][seriesName][index];
                                }
                            });
                        });
                    }
                    
                    btn.classList.remove('loading');
                    btn.classList.add('success');
                    setTimeout(() => btn.classList.remove('success'), 2000);
                } else {
                    btn.classList.remove('loading');
                    btn.classList.add('error');
                    setTimeout(() => btn.classList.remove('error'), 2000);
                }
                
                resetModificationStates();
                renderChart();
            }, 500);
        }

        function confirmColorChanges() {
            const btn = document.getElementById('color-confirm-btn');
            btn.classList.add('loading');
            
            setTimeout(() => {
                if (tempColors[chartManager.currentChart]) {
                    chartManager.modificationHistory.push(
                        JSON.parse(JSON.stringify(chartManager.chartData[chartManager.currentChart]))
                    );
                    
                    if (chartManager.currentChart === 'snowflake') {
                        Object.keys(tempColors[chartManager.currentChart]).forEach(key => {
                            chartManager.chartData[chartManager.currentChart].data[key] = tempColors[chartManager.currentChart][key];
                        });
                    } else {
                        Object.keys(tempColors[chartManager.currentChart]).forEach(seriesIndex => {
                            chartManager.chartData[chartManager.currentChart]
                                .data.series[seriesIndex].color = tempColors[chartManager.currentChart][seriesIndex];
                        });
                    }
                    
                    btn.classList.remove('loading');
                    btn.classList.add('success');
                    setTimeout(() => btn.classList.remove('success'), 2000);
                } else {
                    btn.classList.remove('loading');
                    btn.classList.add('error');
                    setTimeout(() => btn.classList.remove('error'), 2000);
                }
                
                resetModificationStates();
                renderChart();
            }, 500);
        }

        function confirmSettingsChanges() {
            const btn = document.getElementById('settings-confirm-btn');
            btn.classList.add('loading');
            
            setTimeout(() => {
                if (tempSettings[chartManager.currentChart]) {
                    chartManager.modificationHistory.push(
                        JSON.parse(JSON.stringify(chartManager.chartData[chartManager.currentChart]))
                    );
                    
                    Object.keys(tempSettings[chartManager.currentChart]).forEach(key => {
                        const value = tempSettings[chartManager.currentChart][key];
                        if (key === 'title') {
                            chartManager.chartData[chartManager.currentChart].title = value;
                        } else if (key === 'grid') {
                            chartManager.chartData[chartManager.currentChart].layout.grid = value;
                        } else if (key === 'lineStyle') {
                            // ä¿å­˜çº¿å‹è®¾ç½®åˆ°å›¾è¡¨æ•°æ®
                            chartManager.chartData[chartManager.currentChart].data.series.forEach(series => {
                                series.linestyle = value;
                            });
                        }
                    });
                    
                    btn.classList.remove('loading');
                    btn.classList.add('success');
                    setTimeout(() => btn.classList.remove('success'), 2000);
                } else {
                    btn.classList.remove('loading');
                    btn.classList.add('error');
                    setTimeout(() => btn.classList.remove('error'), 2000);
                }
                
                resetModificationStates();
                renderChart();
            }, 500);
        }

        // ================================
        // è¾…åŠ©åŠŸèƒ½
        // ================================

        function resetModificationStates() {
            tempData = {};
            tempColors = {};
            tempSettings = {};
        }

        /**
         * æ˜¾ç¤ºéªŒè¯æ¶ˆæ¯
         */
        function showValidationMessage(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = message;
                element.className = 'validation-message';
                
                switch (type) {
                    case 'success':
                        element.classList.add('validation-success');
                        break;
                    case 'error':
                        element.classList.add('validation-error');
                        break;
                    case 'warning':
                        element.style.background = '#fff3cd';
                        element.style.color = '#856404';
                        break;
                    default:
                        element.style.background = '#d1ecf1';
                        element.style.color = '#0c5460';
                }
                
                // 3ç§’åè‡ªåŠ¨æ¸…é™¤æ¶ˆæ¯
                setTimeout(() => {
                    element.textContent = '';
                    element.className = 'validation-message';
                }, 3000);
            }
        }

        function toggleCollapse(header) {
            const section = header.parentElement;
            const content = header.nextElementSibling;
            const arrow = header.querySelector('.collapse-arrow');
            
            if (content.classList.contains('active')) {
                content.classList.remove('active');
                section.classList.remove('expanded');
                arrow.textContent = 'â–¼';
                // çŸ­æš‚å»¶è¿Ÿåè®¾ç½®è¾ƒå°çš„é«˜åº¦ï¼Œç¡®ä¿åŠ¨ç”»æµç•…
                setTimeout(() => {
                    content.style.maxHeight = '0px';
                }, 50);
            } else {
                section.classList.add('expanded');
                content.classList.add('active');
                arrow.textContent = 'â–²';
                // åŠ¨æ€è®¡ç®—æœ€å¤§é«˜åº¦ä»¥ç¡®ä¿å†…å®¹å®Œå…¨æ˜¾ç¤º
                setTimeout(() => {
                    const scrollHeight = content.scrollHeight;
                    content.style.maxHeight = Math.max(scrollHeight, 500) + 'px';
                }, 10);
            }
        }

        function setTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            document.querySelectorAll('.theme-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // ä¿å­˜ä¸»é¢˜åå¥½
            localStorage.setItem('preferred-theme', theme);
        }

        function resetChart() {
            chartManager.chartData[chartManager.currentChart] = JSON.parse(
                JSON.stringify(chartManager.originalData[chartManager.currentChart])
            );
            initializePage();
        }

        function undoChanges() {
            if (chartManager.modificationHistory.length > 0) {
                const lastState = chartManager.modificationHistory.pop();
                chartManager.chartData[chartManager.currentChart] = lastState;
                initializePage();
            }
        }



        // ================================
        // ä¸‹è½½åŠŸèƒ½
        // ================================

        function downloadChart(format, event) {
            const btn = event.target;
            const originalText = btn.innerHTML;
            
            btn.innerHTML = 'â³ ä¸‹è½½ä¸­...';
            btn.disabled = true;
            
            if (!window.Blob || !window.URL || !window.URL.createObjectURL) {
                showDownloadError('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒHTML5ä¸‹è½½åŠŸèƒ½', btn, originalText);
                return;
            }
            
            if (!Plotly || !Plotly.downloadImage) {
                showDownloadError('Plotlyåº“æœªæ­£ç¡®åŠ è½½', btn, originalText);
                return;
            }
            
            const validFormats = ['png', 'svg', 'jpg', 'jpeg'];
            if (!validFormats.includes(format.toLowerCase())) {
                showDownloadError('ä¸æ”¯æŒçš„æ ¼å¼: ' + format, btn, originalText);
                return;
            }
            
            try {
                const downloadConfig = {
                    format: format.toLowerCase(),
                    filename: `chart-${chartManager.currentChart}-${new Date().getTime()}`,
                    width: 1200,
                    height: 800,
                    scale: 2
                };
                
                if (format.toLowerCase() === 'jpg' || format.toLowerCase() === 'jpeg') {
                    downloadConfig.format = 'jpeg';
                }
                
                Plotly.downloadImage('chart-container', downloadConfig)
                    .then(() => {
                        btn.innerHTML = 'âœ… ä¸‹è½½å®Œæˆ';
                        setTimeout(() => {
                            btn.innerHTML = originalText;
                            btn.disabled = false;
                        }, 2000);
                    })
                    .catch(error => {
                        console.error('ä¸‹è½½å¤±è´¥:', error);
                        showDownloadError('ä¸‹è½½å¤±è´¥: ' + error.message, btn, originalText);
                    });
                    
            } catch (error) {
                console.error('ä¸‹è½½é”™è¯¯:', error);
                showDownloadError('ä¸‹è½½é”™è¯¯: ' + error.message, btn, originalText);
            }
        }

        function showDownloadError(message, btn, originalText) {
            btn.innerHTML = 'âŒ ä¸‹è½½å¤±è´¥';
            
            const errorDiv = document.getElementById('download-error') || createErrorMessageElement();
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            
            setTimeout(() => {
                errorDiv.style.display = 'none';
                btn.innerHTML = originalText;
                btn.disabled = false;
            }, 3000);
        }

        function createErrorMessageElement() {
            const errorDiv = document.createElement('div');
            errorDiv.id = 'download-error';
            errorDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #e74c3c;
                color: white;
                padding: 15px;
                border-radius: 5px;
                z-index: 10000;
                display: none;
                max-width: 300px;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            `;
            document.body.appendChild(errorDiv);
            return errorDiv;
        }



        // ================================
        // é¡µé¢åˆå§‹åŒ–
        // ================================

        document.addEventListener('DOMContentLoaded', function() {
            // åº”ç”¨ä¿å­˜çš„ä¸»é¢˜
            const savedTheme = localStorage.getItem('preferred-theme') || 'light';
            setTheme(savedTheme);
            
            // åˆå§‹åŒ–é¡µé¢
            initializePage();
        });

        // å“åº”å¼è°ƒæ•´
        window.addEventListener('resize', function() {
            renderChart();
        });
    </script>
</body>
</html>